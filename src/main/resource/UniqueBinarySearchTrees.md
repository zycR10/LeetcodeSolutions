# UniqueBinarySearchTrees

## 题目
Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?
给一个正整数n，能形成多少种不同结构的二叉搜索树
 
Example:
Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
 

Constraints:
1 <= n <= 19

## 思路 
这道题真的是太有意思了，兄弟们是不是乍一看不难，然后思考了一会儿使劲往学过的思路去套，然后感觉有点儿意思了开始写代码，然后越写越操蛋？
这道题我们首先分析一下哈，假设n=1，那么就一种没啥说的，n=2的时候就两种了，1和2分别做root节点，这都好理解，那么现在从3开始我们思考一下怎么能找全所有情况。
找全其实不难，3也不是很大的数字，一共就五种结果，关键是要通过n=3来总结出规律：
首先从root结点开始
1.root=1的情况，那么还剩下2和3，都要放在右子树上，那么2和3有几种放法呢？两种，其实就是等于问你n=2的时候有几种不同的树结构对不对？所以n=3，root=1
的情况下一共有两种不同树结构
2.root=2的情况，那么还剩下1和3，一个在左子树，一个在右子树，左子树几种？一个嘛，那就一种，右子树同理一种，所以n=3，root=2的情况下一共只有一种树
3.root=3的情况，那么还剩下1和2，都要放在左子树上，那么1和2有两种，所以n=3，root=3的情况下一共有两种树

那么总共就是2+1+2=5种，ok我们现在再仔细的看看每一种我们是怎么做的，因为二叉树只有左右两个子树，所以确定了root结点之后，能生成几种树就是用左子树的
不同结构数乘以右子树不同结构数，这个不难理解吧，基本的数学知识，注意这里如果子树为空的情况，我们姑且认为有一个null子树，也就是说空也算一种

有了上面这个算法我们再看看三种不同情况是怎么算的，这回就不需要我们在脑袋里画了，根据公式算
1.root=1时，左子树为空那就是1，右子树有两个值，两个值可以变换出两种，所以右子树不同结构数就是2，所以当前情况下总个数为1\*2=2
2.root=2时，左子树一个值为1，右子树一个值也为1，同理总数为1\*1=1
3.root=3时，左子树有两个值，右子树为空，那么总数为2\*1=2

所以现在我们有了n=1时，结果为1，n=2时结果为2，n=3时结果为5，现在有点儿那意思了么，按照上面的思路n=4咋算，那不就是左右子树分类讨论么
1.root = 1, 左子树为空，右子树为3个值
2.root = 2，左子树为1个值，右子树为2个值
3.root = 3，左子树为2个值，右子树为1个值
4.root = 4，左子树为3个值，右子树为空
发现了没，现在我们计算n=4的情况需要用到的值我们都有了吧？因为从n=1到n=3的值我们都已经得到了，那依次类推是不是后面的所有n我们都可以算了，
依靠前面的结果来计算后面的数，是不是动态规划？没看懂的兄弟再仔细看两遍消化一下，这道题确实比较有意思，下面直接上代码，非常简单，一个稍微需要
注意的点，设动态规划数组为dp[]，dp\[0\]我们代表空树的情况，空树我们也按一个空节点处理，所以先初始化dp\[0\] = 1，当然了dp\[1\]肯定也是1

## 实现 
```
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```